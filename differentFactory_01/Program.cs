public class Предприятие
{
    public Dictionary<int, int> ФункцияДохода { get; set; }

    public Предприятие()
    {
        // Инициализируем функцию дохода как словарь
        ФункцияДохода = new Dictionary<int, int>();
    }

    // Метод для получения дохода от заданной инвестиции
    public int ПолучитьДоход(int инвестиция)
    {
        if (ФункцияДохода.ContainsKey(инвестиция))
            return ФункцияДохода[инвестиция];
        else
            return 0; // Предполагаем нулевой доход, если сумма инвестиций недоступна
    }
}

public class ОптимизацияИнвестиций
{
    public static void Main(string[] args)
    {
        // Настройка входных параметров
        Console.WriteLine("Введите общую сумму инвестиций (например, 200):");
        var общаяСуммаИнвестиций = int.Parse(Console.ReadLine());

        Console.WriteLine("Введите базовый размер инвестиций (например, 40):");
        var базовыйРазмер = int.Parse(Console.ReadLine());

        Console.WriteLine("Введите количество предприятий:");
        var количествоПредприятий = int.Parse(Console.ReadLine());

        // Создаем список предприятий
        var предприятия = new List<Предприятие>();

        for (var i = 0; i < количествоПредприятий; i++)
        {
            var предприятие = new Предприятие();

            Console.WriteLine($"\nВведите количество возможных инвестиций для предприятия {i + 1}:");
            var количествоВариантов = int.Parse(Console.ReadLine());

            Console.WriteLine($"Введите пары 'инвестиция - доход' для предприятия {i + 1}:");
            for (var j = 0; j < количествоВариантов; j++)
            {
                Console.WriteLine("Введите размер инвестиций (кратно базовому размеру):");
                var инвестиция = int.Parse(Console.ReadLine());

                Console.WriteLine("Введите доход от этой инвестиции:");
                var доход = int.Parse(Console.ReadLine());

                // Заполняем функцию дохода для текущего предприятия
                предприятие.ФункцияДохода[инвестиция] = доход;
            }

            // Убедимся, что возможность инвестировать 0 тоже учитывается
            if (!предприятие.ФункцияДохода.ContainsKey(0))
            {
                предприятие.ФункцияДохода[0] = 0;
            }

            // Добавляем предприятие в список
            предприятия.Add(предприятие);
        }

        // Реализация динамического программирования
        var максимальнаяСумма = общаяСуммаИнвестиций; // Максимальная доступная сумма инвестиций
        var n = количествоПредприятий; // Количество предприятий
        var количествоСостоянийСредств = (максимальнаяСумма / базовыйРазмер) + 1; // Количество возможных состояний средств

        // Инициализируем таблицы для хранения максимального дохода и оптимальных инвестиций
        var Z = new int[n + 1, количествоСостоянийСредств]; // Таблица максимального дохода
        var xЗвезда = new int[n + 1, количествоСостоянийСредств]; // Таблица оптимальных инвестиций

        // Инициализация для последнего предприятия
        var k = n - 1; // Индекс последнего предприятия
        for (int f = 0; f < количествоСостоянийСредств; f++)
        {
            var ξ = f * базовыйРазмер; // Текущая сумма средств
            var максимальныйДоход = 0; // Максимальный доход
            var оптимальнаяИнвестиция = 0; // Оптимальный размер инвестиций

            // Перебираем все возможные инвестиции для последнего предприятия
            foreach (var инвестиция in предприятия[k].ФункцияДохода.Keys)
            {
                if (инвестиция <= ξ)
                {
                    var доход = предприятия[k].ПолучитьДоход(инвестиция);

                    // Обновляем максимальный доход и соответствующую инвестицию
                    if (доход > максимальныйДоход)
                    {
                        максимальныйДоход = доход;
                        оптимальнаяИнвестиция = инвестиция;
                    }
                }
            }

            // Заполняем таблицы Z и xЗвезда для последнего предприятия
            Z[k, f] = максимальныйДоход;
            xЗвезда[k, f] = оптимальнаяИнвестиция;
        }

        // Динамическое программирование для остальных предприятий
        for (k = n - 2; k >= 0; k--)
        {
            for (var f = 0; f < количествоСостоянийСредств; f++)
            {
                var ξ = f * базовыйРазмер; // Текущая сумма средств
                var максимальныйДоход = 0; // Максимальный доход
                var оптимальнаяИнвестиция = 0; // Оптимальный размер инвестиций

                // Перебираем все возможные инвестиции для текущего предприятия
                foreach (var инвестиция in предприятия[k].ФункцияДохода.Keys)
                {
                    if (инвестиция <= ξ)
                    {
                        var доход = предприятия[k].ПолучитьДоход(инвестиция);
                        var оставшиесяСредства = ξ - инвестиция; // Оставшиеся средства после инвестиции
                        var индексОставшихсяСредств = оставшиесяСредства / базовыйРазмер; // Индекс оставшихся средств
                        var будущийДоход = Z[k + 1, индексОставшихсяСредств]; // Максимальный доход от последующих предприятий
                        var общийДоход = доход + будущийДоход; // Общий доход

                        // Обновляем максимальный доход и соответствующую инвестицию
                        if (общийДоход > максимальныйДоход)
                        {
                            максимальныйДоход = общийДоход;
                            оптимальнаяИнвестиция = инвестиция;
                        }
                    }
                }

                // Заполняем таблицы Z и xЗвезда для текущего предприятия
                Z[k, f] = максимальныйДоход;
                xЗвезда[k, f] = оптимальнаяИнвестиция;
            }
        }

        // Восстановление оптимального распределения инвестиций
        var оптимальноеРаспределение = new int[n]; // Массив для хранения оптимальных инвестиций по предприятиям
        var оставшиесяСредстваВсего = общаяСуммаИнвестиций; // Оставшиеся средства

        for (k = 0; k < n; k++)
        {
            var f = оставшиесяСредстваВсего / базовыйРазмер; // Индекс текущего состояния средств
            var xk = xЗвезда[k, f]; // Оптимальная инвестиция для текущего предприятия
            оптимальноеРаспределение[k] = xk; // Сохраняем оптимальную инвестицию
            оставшиесяСредстваВсего -= xk; // Обновляем оставшиеся средства
        }

        // Вывод результатов
        Console.WriteLine("\nОптимальное распределение инвестиций:");
        for (k = 0; k < n; k++)
        {
            Console.WriteLine($"Предприятие {k + 1}: {оптимальноеРаспределение[k]} млн руб.");
        }

        var максимальныйОбщийДоход = Z[0, общаяСуммаИнвестиций / базовыйРазмер]; // Максимальный общий доход
        Console.WriteLine($"\nМаксимальный общий доход: {максимальныйОбщийДоход} млн руб.");
    }
}
